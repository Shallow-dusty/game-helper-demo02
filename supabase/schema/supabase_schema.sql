-- ============================================================
-- Blood on the Clocktower Game Helper - Supabase Schema
-- ============================================================

-- Create a table for game rooms (public game state)
create table game_rooms (
  id bigint generated by default as identity primary key,
  room_code text not null unique,
  data jsonb not null default '{}'::jsonb,
  storyteller_id uuid,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Realtime for game_rooms
alter publication supabase_realtime add table game_rooms;

-- Storyteller-only secret state (split from public state)
create table if not exists game_secrets (
  room_code text primary key references game_rooms(room_code) on delete cascade,
  data jsonb not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Room membership and per-player secret overlays
create table if not exists room_members (
  id bigint generated by default as identity primary key,
  room_id bigint not null references game_rooms(id) on delete cascade,
  user_id uuid not null,
  display_name text,
  role text not null default 'player',
  seat_id int,
  seen_role_id text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(room_id, user_id)
);

-- Game history archive
create table if not exists game_history (
  id bigint generated by default as identity primary key,
  room_code text not null references game_rooms(room_code) on delete cascade,
  winner text,
  reason text,
  script_name text,
  players jsonb,
  messages jsonb,
  state jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create a table for seat secrets (ST-only sensitive information)
-- This stores information that only the storyteller should see
create table seat_secrets (
  id bigint generated by default as identity primary key,
  room_id bigint not null references game_rooms(id) on delete cascade,
  seat_id int not null,  -- seat position 0-15
  real_role_id text,     -- actual role (hidden from player if drunk/poisoned etc)
  is_poisoned boolean default false,
  is_drunk boolean default false,
  is_mad text,           -- reason for madness if applicable
  extra_info jsonb default '{}'::jsonb, -- for role-specific hidden info
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  unique(room_id, seat_id)
);

-- Create a table for game messages (chat + system events)
create table game_messages (
  id bigint generated by default as identity primary key,
  room_id bigint not null references game_rooms(id) on delete cascade,
  sender_seat_id int,           -- null for system messages
  sender_name text,             -- player name or "说书人" or "系统"
  content text not null,
  recipient_seat_id int,        -- null for public, specific seat for private
  message_type text default 'chat',  -- 'chat', 'system', 'night_action', 'ability'
  metadata jsonb default '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Realtime for game_messages
alter publication supabase_realtime add table game_messages;

-- Enable Realtime for room_members and game_history
do $$
begin
  alter publication supabase_realtime add table room_members;
exception when duplicate_object then
  null;
end $$;

do $$
begin
  alter publication supabase_realtime add table game_history;
exception when duplicate_object then
  null;
end $$;

-- ============================================================
-- Row Level Security (RLS) Policies
-- ============================================================

alter table game_rooms enable row level security;
alter table room_members enable row level security;
alter table game_secrets enable row level security;
alter table seat_secrets enable row level security;
alter table game_messages enable row level security;
alter table interaction_logs enable row level security;
alter table daily_nominations enable row level security;
alter table game_history enable row level security;

-- game_rooms policies
drop policy if exists "game_rooms_select" on game_rooms;
drop policy if exists "game_rooms_insert" on game_rooms;
drop policy if exists "game_rooms_update" on game_rooms;

create policy "game_rooms_select"
on game_rooms for select
using (auth.role() = 'service_role' or auth.uid() is not null);

create policy "game_rooms_insert"
on game_rooms for insert
with check (auth.role() = 'service_role' or auth.uid() = storyteller_id);

create policy "game_rooms_update"
on game_rooms for update
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = game_rooms.id
      and rm.user_id = auth.uid()
      and rm.role = 'storyteller'
  )
);

-- room_members policies
drop policy if exists "room_members_select" on room_members;
drop policy if exists "room_members_insert" on room_members;
drop policy if exists "room_members_update" on room_members;
drop policy if exists "room_members_delete" on room_members;

create policy "room_members_select"
on room_members for select
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = room_members.room_id
      and rm.user_id = auth.uid()
  )
);

create policy "room_members_insert"
on room_members for insert
with check (auth.role() = 'service_role' or auth.uid() = user_id);

create policy "room_members_update"
on room_members for update
using (
  auth.role() = 'service_role' or
  auth.uid() = user_id or
  exists (
    select 1 from game_rooms gr
    where gr.id = room_members.room_id
      and gr.storyteller_id = auth.uid()
  )
);

create policy "room_members_delete"
on room_members for delete
using (
  auth.role() = 'service_role' or
  auth.uid() = user_id or
  exists (
    select 1 from game_rooms gr
    where gr.id = room_members.room_id
      and gr.storyteller_id = auth.uid()
  )
);

-- game_secrets policies
drop policy if exists "game_secrets_select" on game_secrets;
drop policy if exists "game_secrets_insert" on game_secrets;
drop policy if exists "game_secrets_update" on game_secrets;
drop policy if exists "game_secrets_delete" on game_secrets;

create policy "game_secrets_select"
on game_secrets for select
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.room_code = game_secrets.room_code
      and gr.storyteller_id = auth.uid()
  )
);

create policy "game_secrets_insert"
on game_secrets for insert
with check (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.room_code = game_secrets.room_code
      and gr.storyteller_id = auth.uid()
  )
);

create policy "game_secrets_update"
on game_secrets for update
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.room_code = game_secrets.room_code
      and gr.storyteller_id = auth.uid()
  )
);

create policy "game_secrets_delete"
on game_secrets for delete
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.room_code = game_secrets.room_code
      and gr.storyteller_id = auth.uid()
  )
);

-- seat_secrets policies (storyteller only)
drop policy if exists "seat_secrets_select_st_only" on seat_secrets;
drop policy if exists "seat_secrets_insert_st_only" on seat_secrets;
drop policy if exists "seat_secrets_update_st_only" on seat_secrets;
drop policy if exists "seat_secrets_delete_st_only" on seat_secrets;

create policy "seat_secrets_select_st_only"
on seat_secrets for select
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.id = seat_secrets.room_id
      and gr.storyteller_id = auth.uid()
  )
);

create policy "seat_secrets_insert_st_only"
on seat_secrets for insert
with check (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.id = seat_secrets.room_id
      and gr.storyteller_id = auth.uid()
  )
);

create policy "seat_secrets_update_st_only"
on seat_secrets for update
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.id = seat_secrets.room_id
      and gr.storyteller_id = auth.uid()
  )
);

create policy "seat_secrets_delete_st_only"
on seat_secrets for delete
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.id = seat_secrets.room_id
      and gr.storyteller_id = auth.uid()
  )
);

-- game_messages policies (members only)
drop policy if exists "game_messages_select" on game_messages;
drop policy if exists "game_messages_insert" on game_messages;

create policy "game_messages_select"
on game_messages for select
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = game_messages.room_id
      and rm.user_id = auth.uid()
  )
);

create policy "game_messages_insert"
on game_messages for insert
with check (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = game_messages.room_id
      and rm.user_id = auth.uid()
  )
);

-- interaction_logs policies (storyteller only)
drop policy if exists "interaction_logs_select" on interaction_logs;
drop policy if exists "interaction_logs_insert" on interaction_logs;
drop policy if exists "interaction_logs_update" on interaction_logs;

create policy "interaction_logs_select"
on interaction_logs for select
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = interaction_logs.room_id
      and rm.user_id = auth.uid()
      and rm.role = 'storyteller'
  )
);

create policy "interaction_logs_insert"
on interaction_logs for insert
with check (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = interaction_logs.room_id
      and rm.user_id = auth.uid()
      and rm.role = 'storyteller'
  )
);

create policy "interaction_logs_update"
on interaction_logs for update
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = interaction_logs.room_id
      and rm.user_id = auth.uid()
      and rm.role = 'storyteller'
  )
);

-- daily_nominations policies (storyteller only)
drop policy if exists "daily_nominations_select" on daily_nominations;
drop policy if exists "daily_nominations_insert" on daily_nominations;
drop policy if exists "daily_nominations_update" on daily_nominations;

create policy "daily_nominations_select"
on daily_nominations for select
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = daily_nominations.room_id
      and rm.user_id = auth.uid()
      and rm.role = 'storyteller'
  )
);

create policy "daily_nominations_insert"
on daily_nominations for insert
with check (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = daily_nominations.room_id
      and rm.user_id = auth.uid()
      and rm.role = 'storyteller'
  )
);

create policy "daily_nominations_update"
on daily_nominations for update
using (
  auth.role() = 'service_role' or
  exists (
    select 1 from room_members rm
    where rm.room_id = daily_nominations.room_id
      and rm.user_id = auth.uid()
      and rm.role = 'storyteller'
  )
);

-- game_history policies
drop policy if exists "game_history_select" on game_history;
drop policy if exists "game_history_insert" on game_history;

create policy "game_history_select"
on game_history for select
using (auth.role() = 'service_role' or auth.uid() is not null);

create policy "game_history_insert"
on game_history for insert
with check (
  auth.role() = 'service_role' or
  exists (
    select 1 from game_rooms gr
    where gr.room_code = game_history.room_code
      and gr.storyteller_id = auth.uid()
  )
);

-- ============================================================
-- Atomic Seat Claiming Function (Prevents Race Conditions)
-- 修复：使用 userId + userName 代替 player 以匹配前端数据结构
-- ============================================================

create or replace function claim_seat(
  p_room_code text,
  p_seat_id int,
  p_user_id text,
  p_player_name text,
  p_client_token text
) returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room_data jsonb;
  v_seats jsonb;
  v_target_seat jsonb;
  v_existing_seat jsonb;
  v_result jsonb;
  v_seat_index int;
begin
  if auth.uid() is null then
    return jsonb_build_object('success', false, 'error', 'Not authenticated');
  end if;
  if auth.uid()::text != p_user_id then
    return jsonb_build_object('success', false, 'error', 'User mismatch');
  end if;
  -- Lock the room row for update
  select data into v_room_data
  from game_rooms
  where room_code = p_room_code
  for update;
  
  if v_room_data is null then
    return jsonb_build_object('success', false, 'error', 'Room not found');
  end if;
  
  v_seats := v_room_data->'seats';
  
  if v_seats is null then
    return jsonb_build_object('success', false, 'error', 'No seats in room');
  end if;
  
  -- Check if user already has a seat in this room
  for v_seat_index in 0..jsonb_array_length(v_seats)-1 loop
    v_existing_seat := v_seats->v_seat_index;
    if v_existing_seat->>'userId' = p_user_id and v_seat_index != p_seat_id then
      return jsonb_build_object('success', false, 'error', 'You already have seat ' || (v_seat_index + 1));
    end if;
  end loop;
  
  -- Check if seat is already taken
  v_target_seat := v_seats->p_seat_id;
  
  if v_target_seat is not null 
     and v_target_seat->>'userId' is not null 
     and v_target_seat->>'userId' != '' 
     and v_target_seat->>'userId' != p_user_id then
    return jsonb_build_object('success', false, 'error', 'Seat already taken', 'currentPlayer', v_target_seat->>'userName');
  end if;
  
  -- Preserve existing seat data and update player info
  v_seats := jsonb_set(
    v_seats,
    array[p_seat_id::text],
    (v_target_seat || jsonb_build_object(
      'id', p_seat_id,
      'userId', p_user_id,
      'userName', p_player_name,
      'isVirtual', false,
      'clientToken', p_client_token
    ))
  );
  
  -- Save updated data
  update game_rooms
  set 
    data = jsonb_set(v_room_data, '{seats}', v_seats),
    updated_at = now()
  where room_code = p_room_code;
  
  return jsonb_build_object('success', true, 'seat', v_seats->p_seat_id);
end;
$$;

-- ============================================================
-- Leave Seat Function
-- 修复：使用 userId/userName 代替 player，正确清空座位
-- ============================================================

create or replace function leave_seat(
  p_room_code text,
  p_seat_id int,
  p_client_token text
) returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room_data jsonb;
  v_seats jsonb;
  v_target_seat jsonb;
begin
  if auth.uid() is null then
    return jsonb_build_object('success', false, 'error', 'Not authenticated');
  end if;
  -- Lock the room row for update
  select data into v_room_data
  from game_rooms
  where room_code = p_room_code
  for update;
  
  if v_room_data is null then
    return jsonb_build_object('success', false, 'error', 'Room not found');
  end if;
  
  v_seats := v_room_data->'seats';
  v_target_seat := v_seats->p_seat_id;

  if v_target_seat->>'userId' != auth.uid()::text then
    return jsonb_build_object('success', false, 'error', 'Not your seat');
  end if;

  -- Verify client token matches (only owner can leave)
  if v_target_seat->>'clientToken' != p_client_token then
    return jsonb_build_object('success', false, 'error', 'Not your seat');
  end if;
  
  -- Clear the seat (preserve structure, clear user)
  v_seats := jsonb_set(
    v_seats,
    array[p_seat_id::text],
    (v_target_seat || jsonb_build_object(
      'userId', null,
      'userName', '',
      'isVirtual', false,
      'clientToken', null
    )) - 'userId' - 'userName' - 'clientToken' || jsonb_build_object(
      'id', p_seat_id,
      'userId', null,
      'userName', '',
      'isVirtual', false
    )
  );
  
  -- Save updated data
  update game_rooms
  set 
    data = jsonb_set(v_room_data, '{seats}', v_seats),
    updated_at = now()
  where room_code = p_room_code;
  
  return jsonb_build_object('success', true);
end;
$$;

-- ============================================================
-- Indexes for Performance
-- ============================================================

create index if not exists idx_game_rooms_room_code on game_rooms(room_code);
create index if not exists idx_room_members_room_id on room_members(room_id);
create index if not exists idx_room_members_user_id on room_members(user_id);
create index if not exists idx_game_history_room_code on game_history(room_code);
create index if not exists idx_seat_secrets_room_id on seat_secrets(room_id);
create index if not exists idx_game_messages_room_id on game_messages(room_id);
create index if not exists idx_game_messages_created_at on game_messages(created_at);

-- ============================================================
-- Toggle Hand Function (Atomic Voting)
-- ============================================================

create or replace function toggle_hand(
  p_room_code text,
  p_seat_id int,
  p_user_id text
) returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room_data jsonb;
  v_seats jsonb;
  v_target_seat jsonb;
  v_is_hand_raised boolean;
begin
  if auth.uid() is null then
    return jsonb_build_object('success', false, 'error', 'Not authenticated');
  end if;
  if auth.uid()::text != p_user_id then
    return jsonb_build_object('success', false, 'error', 'User mismatch');
  end if;
  -- Lock the room row for update
  select data into v_room_data
  from game_rooms
  where room_code = p_room_code
  for update;
  
  if v_room_data is null then
    return jsonb_build_object('success', false, 'error', 'Room not found');
  end if;
  
  v_seats := v_room_data->'seats';
  v_target_seat := v_seats->p_seat_id;
  
  -- Verify user owns the seat
  if v_target_seat->>'userId' != p_user_id then
    return jsonb_build_object('success', false, 'error', 'Not your seat');
  end if;
  
  -- Toggle hand
  v_is_hand_raised := coalesce((v_target_seat->>'isHandRaised')::boolean, false);
  
  v_seats := jsonb_set(
    v_seats,
    array[p_seat_id::text, 'isHandRaised'],
    to_jsonb(not v_is_hand_raised)
  );
  
  -- Save updated data
  update game_rooms
  set 
    data = jsonb_set(v_room_data, '{seats}', v_seats),
    updated_at = now()
  where room_code = p_room_code;
  
  return jsonb_build_object('success', true, 'isHandRaised', not v_is_hand_raised);
end;
$$;

-- ============================================================
-- Submit Night Action Function
-- ============================================================

create or replace function submit_night_action(
  p_room_code text,
  p_seat_id int,
  p_role_id text,
  p_payload jsonb
) returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room_data jsonb;
  v_requests jsonb;
  v_new_request jsonb;
  v_seats jsonb;
  v_target_seat jsonb;
begin
  if auth.uid() is null then
    return jsonb_build_object('success', false, 'error', 'Not authenticated');
  end if;
  select data into v_room_data from game_rooms where room_code = p_room_code for update;
  
  if v_room_data is null then return jsonb_build_object('success', false, 'error', 'Room not found'); end if;
  v_seats := v_room_data->'seats';
  v_target_seat := v_seats->p_seat_id;
  if v_target_seat->>'userId' != auth.uid()::text then
    return jsonb_build_object('success', false, 'error', 'Not your seat');
  end if;
  
  v_requests := coalesce(v_room_data->'nightActionRequests', '[]'::jsonb);
  
  v_new_request := jsonb_build_object(
    'id', gen_random_uuid(),
    'seatId', p_seat_id,
    'roleId', p_role_id,
    'payload', p_payload,
    'status', 'pending',
    'timestamp', extract(epoch from now()) * 1000
  );
  
  v_requests := v_requests || v_new_request;
  
  update game_rooms
  set data = jsonb_set(v_room_data, '{nightActionRequests}', v_requests),
      updated_at = now()
  where room_code = p_room_code;
  
  return jsonb_build_object('success', true);
end;
$$;

-- ============================================================
-- Toggle Ready Function
-- ============================================================

create or replace function toggle_ready(
  p_room_code text,
  p_seat_id int
) returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_room_data jsonb;
  v_seats jsonb;
  v_target_seat jsonb;
  v_ready boolean;
begin
  if auth.uid() is null then
    return jsonb_build_object('success', false, 'error', 'Not authenticated');
  end if;

  select data into v_room_data
  from game_rooms
  where room_code = p_room_code
  for update;

  if v_room_data is null then
    return jsonb_build_object('success', false, 'error', 'Room not found');
  end if;

  v_seats := v_room_data->'seats';
  v_target_seat := v_seats->p_seat_id;

  if v_target_seat->>'userId' != auth.uid()::text then
    return jsonb_build_object('success', false, 'error', 'Not your seat');
  end if;

  v_ready := coalesce((v_target_seat->>'isReady')::boolean, false);

  v_seats := jsonb_set(
    v_seats,
    array[p_seat_id::text, 'isReady'],
    to_jsonb(not v_ready)
  );

  update game_rooms
  set data = jsonb_set(v_room_data, '{seats}', v_seats),
      updated_at = now()
  where room_code = p_room_code;

  return jsonb_build_object('success', true, 'isReady', not v_ready);
end;
$$;
