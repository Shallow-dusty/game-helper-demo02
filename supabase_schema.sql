-- ============================================================
-- Blood on the Clocktower Game Helper - Supabase Schema
-- ============================================================

-- Create a table for game rooms (public game state)
create table game_rooms (
  id bigint generated by default as identity primary key,
  room_code text not null unique,
  data jsonb not null default '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Realtime for game_rooms
alter publication supabase_realtime add table game_rooms;

-- Create a table for seat secrets (ST-only sensitive information)
-- This stores information that only the storyteller should see
create table seat_secrets (
  id bigint generated by default as identity primary key,
  room_id bigint not null references game_rooms(id) on delete cascade,
  seat_id int not null,  -- seat position 0-15
  real_role_id text,     -- actual role (hidden from player if drunk/poisoned etc)
  is_poisoned boolean default false,
  is_drunk boolean default false,
  is_mad text,           -- reason for madness if applicable
  extra_info jsonb default '{}'::jsonb, -- for role-specific hidden info
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  unique(room_id, seat_id)
);

-- Create a table for game messages (chat + system events)
create table game_messages (
  id bigint generated by default as identity primary key,
  room_id bigint not null references game_rooms(id) on delete cascade,
  sender_seat_id int,           -- null for system messages
  sender_name text,             -- player name or "说书人" or "系统"
  content text not null,
  recipient_seat_id int,        -- null for public, specific seat for private
  message_type text default 'chat',  -- 'chat', 'system', 'night_action', 'ability'
  metadata jsonb default '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Realtime for game_messages
alter publication supabase_realtime add table game_messages;

-- ============================================================
-- Row Level Security (RLS) Policies
-- ============================================================

-- Game Rooms: Everyone can read/write (public game state)
alter table game_rooms enable row level security;

create policy "game_rooms_select"
on game_rooms for select
using (true);

create policy "game_rooms_insert"
on game_rooms for insert
with check (true);

create policy "game_rooms_update"
on game_rooms for update
using (true);

-- Seat Secrets: Only ST can access (in production, add proper auth check)
-- For demo, we'll use a header-based approach: x-storyteller-token
alter table seat_secrets enable row level security;

-- In a production app, you'd verify the ST token server-side
-- For demo purposes, we allow select/insert/update if the client provides correct room access
create policy "seat_secrets_select_st_only"
on seat_secrets for select
using (
  -- In production: auth.uid() = (select storyteller_id from game_rooms where id = room_id)
  true  -- Demo: client-side filtering
);

create policy "seat_secrets_insert_st_only"
on seat_secrets for insert
with check (true);

create policy "seat_secrets_update_st_only"
on seat_secrets for update
using (true);

create policy "seat_secrets_delete_st_only"
on seat_secrets for delete
using (true);

-- Game Messages: Public messages visible to all, private only to sender/recipient
alter table game_messages enable row level security;

create policy "game_messages_select"
on game_messages for select
using (
  -- Public messages (no recipient) or messages where user is sender/recipient
  -- Demo: client-side filtering based on seat_id
  true
);

create policy "game_messages_insert"
on game_messages for insert
with check (true);

-- ============================================================
-- Atomic Seat Claiming Function (Prevents Race Conditions)
-- 修复：使用 userId + userName 代替 player 以匹配前端数据结构
-- ============================================================

create or replace function claim_seat(
  p_room_code text,
  p_seat_id int,
  p_user_id text,
  p_player_name text,
  p_client_token text
) returns jsonb
language plpgsql
security definer
as $$
declare
  v_room_data jsonb;
  v_seats jsonb;
  v_target_seat jsonb;
  v_existing_seat jsonb;
  v_result jsonb;
  v_seat_index int;
begin
  -- Lock the room row for update
  select data into v_room_data
  from game_rooms
  where room_code = p_room_code
  for update;
  
  if v_room_data is null then
    return jsonb_build_object('success', false, 'error', 'Room not found');
  end if;
  
  v_seats := v_room_data->'seats';
  
  if v_seats is null then
    return jsonb_build_object('success', false, 'error', 'No seats in room');
  end if;
  
  -- Check if user already has a seat in this room
  for v_seat_index in 0..jsonb_array_length(v_seats)-1 loop
    v_existing_seat := v_seats->v_seat_index;
    if v_existing_seat->>'userId' = p_user_id and v_seat_index != p_seat_id then
      return jsonb_build_object('success', false, 'error', 'You already have seat ' || (v_seat_index + 1));
    end if;
  end loop;
  
  -- Check if seat is already taken
  v_target_seat := v_seats->p_seat_id;
  
  if v_target_seat is not null 
     and v_target_seat->>'userId' is not null 
     and v_target_seat->>'userId' != '' 
     and v_target_seat->>'userId' != p_user_id then
    return jsonb_build_object('success', false, 'error', 'Seat already taken', 'currentPlayer', v_target_seat->>'userName');
  end if;
  
  -- Preserve existing seat data and update player info
  v_seats := jsonb_set(
    v_seats,
    array[p_seat_id::text],
    (v_target_seat || jsonb_build_object(
      'id', p_seat_id,
      'userId', p_user_id,
      'userName', p_player_name,
      'isVirtual', false,
      'clientToken', p_client_token
    ))
  );
  
  -- Save updated data
  update game_rooms
  set 
    data = jsonb_set(v_room_data, '{seats}', v_seats),
    updated_at = now()
  where room_code = p_room_code;
  
  return jsonb_build_object('success', true, 'seat', v_seats->p_seat_id);
end;
$$;

-- ============================================================
-- Leave Seat Function
-- 修复：使用 userId/userName 代替 player，正确清空座位
-- ============================================================

create or replace function leave_seat(
  p_room_code text,
  p_seat_id int,
  p_client_token text
) returns jsonb
language plpgsql
security definer
as $$
declare
  v_room_data jsonb;
  v_seats jsonb;
  v_target_seat jsonb;
begin
  -- Lock the room row for update
  select data into v_room_data
  from game_rooms
  where room_code = p_room_code
  for update;
  
  if v_room_data is null then
    return jsonb_build_object('success', false, 'error', 'Room not found');
  end if;
  
  v_seats := v_room_data->'seats';
  v_target_seat := v_seats->p_seat_id;
  
  -- Verify client token matches (only owner can leave)
  if v_target_seat->>'clientToken' != p_client_token then
    return jsonb_build_object('success', false, 'error', 'Not your seat');
  end if;
  
  -- Clear the seat (preserve structure, clear user)
  v_seats := jsonb_set(
    v_seats,
    array[p_seat_id::text],
    (v_target_seat || jsonb_build_object(
      'userId', null,
      'userName', '',
      'isVirtual', false,
      'clientToken', null
    )) - 'userId' - 'userName' - 'clientToken' || jsonb_build_object(
      'id', p_seat_id,
      'userId', null,
      'userName', '',
      'isVirtual', false
    )
  );
  
  -- Save updated data
  update game_rooms
  set 
    data = jsonb_set(v_room_data, '{seats}', v_seats),
    updated_at = now()
  where room_code = p_room_code;
  
  return jsonb_build_object('success', true);
end;
$$;

-- ============================================================
-- Indexes for Performance
-- ============================================================

create index if not exists idx_game_rooms_room_code on game_rooms(room_code);
create index if not exists idx_seat_secrets_room_id on seat_secrets(room_id);
create index if not exists idx_game_messages_room_id on game_messages(room_id);
create index if not exists idx_game_messages_created_at on game_messages(created_at);
